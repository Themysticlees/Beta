package dp_Problems.StringProblems;
import java.util.*;
/*
 * We are given two strings, ‘TEXT' and ‘S’. We have to calculate the no. of subsequences 
 * of ‘TEXT’, which are equal to ‘S’. Since the answer can be very large print it modulo (10^9)+7.
 * A Subsequence of a string is the string that is generated by deleting 0 or more letters 
 * from the string and keeping the rest of the letters in the same order.
 * 
 * 
	For Example:
	‘TEXT’ = “brootgroot” and ‘S’ = “brt” 
	Following subsequences formed by characters at given indices (1-based) of TEXT are counted
	1 2 5
	1 2 10
	1 7 10
	
	So, our output will be:
	3
 */
public class SubsequenceCounting {
	/*
	 * Thus, you have to find the no.of subsequences of string A which matches with string B
	 * 
	 * The intuition will be, if the characters of both the indexes match, then we move ahead.
	 * We also might not take that character of string A which matches and try to find another 
	 * occurrence of the character from string B. In this way we can find all the subsequences which 
	 * matches string B.
	 * 
	 * And if the character doesn't match we anyway move the String A index forward
	 */
	public static int subsequenceCounting(String t, String s, int lt, int ls) {
        // Write your code here..
        
//        int[][] dp = new int[lt][ls];
//        
//        for(int[] i:dp)
//            Arrays.fill(i,-1);
//        
//        return helper(t,s,lt-1,ls-1,dp);
        
		//1D array optimization
		//since we are just using the prev row to calculate the curr row
		//and the elements to left of the curr index is used to calculate
		//Thus we can use the same 1D array, just start iterating from the end and move forward 
		//and store the ans in the same array
        int[] curr=new int[ls+1];
	
	     curr[0]=1;
	     
	     for(int i=1;i<=lt;i++){
	         for(int j=ls;j>=1;j--){
	             if(t.charAt(i-1)==s.charAt(j-1))
	                 curr[j]=(curr[j-1]
	                                  +curr[j]) %1000000007;
	             else
	                 curr[j]=curr[j] %1000000007;
	         }
	     }
	     
	     return curr[ls];
	    }
	
	//Tabulation
	public static int tabulation(String t, String s, int lt, int ls) {
		
		int[][] dp = new int[lt+1][ls+1];
        
		//The first parameter is for String A, second for String B
		//thus mark the indexes 1 where String B index becomes 0 (same as j<0)
		//Here we have used Index shifting as -1 cannot be represented as an index
        for(int i=0;i<=lt;i++)
            dp[i][0]=1;
        
        //Copy the recurrence relation
        for(int i=1;i<=lt;i++){
            for(int j=1;j<=ls;j++){
                if(t.charAt(i-1)==s.charAt(j-1))
                    dp[i][j]=(dp[i-1][j-1]
                                     +dp[i-1][j]) %1000000007;
                else
                    dp[i][j]=dp[i-1][j] %1000000007;
            }
        }
        
        return dp[lt][ls];	
	}
    
	//Memoization
    public static int helper(String t, String s, int i, int j, int[][] dp){
        
    	//-----------Base cases--------------//
    	/*
    	 * If string A exhausts(i<0) then there are no more characters left to match with string B
    	 * Thus subsequence not possible, return 0.
    	 * 
    	 * If string B exhausts(j<0) then string B has been found in string A thus just return 1
    	 */
        if(j<0)
            return 1;
        if(i<0)
            return 0;
        
        //if already calculated
        if(dp[i][j]!=-1)
            return dp[i][j];
        
        //Recurrence relation
        if(t.charAt(i)==s.charAt(j))
            return dp[i][j]=(helper(t,s,i-1,j-1,dp)
                             +helper(t,s,i-1,j,dp)) %1000000007;
        else
            return dp[i][j]=helper(t,s,i-1,j,dp) %1000000007;
    }

	
}
